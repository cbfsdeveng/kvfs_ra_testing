// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config.proto

#ifndef PROTOBUF_config_2eproto__INCLUDED
#define PROTOBUF_config_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pqfs {
namespace config {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_config_2eproto();
void protobuf_AssignDesc_config_2eproto();
void protobuf_ShutdownFile_config_2eproto();

class Config;
class Primary;
class KeyValueStore;
class Tiering;
class Cloud;

enum KeyValueStore_Type {
  KeyValueStore_Type_ROXDB = 0,
  KeyValueStore_Type_LEVELDB = 1,
  KeyValueStore_Type_RAMCLOUD = 2
};
bool KeyValueStore_Type_IsValid(int value);
const KeyValueStore_Type KeyValueStore_Type_Type_MIN = KeyValueStore_Type_ROXDB;
const KeyValueStore_Type KeyValueStore_Type_Type_MAX = KeyValueStore_Type_RAMCLOUD;
const int KeyValueStore_Type_Type_ARRAYSIZE = KeyValueStore_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* KeyValueStore_Type_descriptor();
inline const ::std::string& KeyValueStore_Type_Name(KeyValueStore_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    KeyValueStore_Type_descriptor(), value);
}
inline bool KeyValueStore_Type_Parse(
    const ::std::string& name, KeyValueStore_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KeyValueStore_Type>(
    KeyValueStore_Type_descriptor(), name, value);
}
enum KeyValueStore_PersistenceRule {
  KeyValueStore_PersistenceRule_ON_WRITE = 0,
  KeyValueStore_PersistenceRule_ON_CLOSE = 1,
  KeyValueStore_PersistenceRule_LAZY = 2
};
bool KeyValueStore_PersistenceRule_IsValid(int value);
const KeyValueStore_PersistenceRule KeyValueStore_PersistenceRule_PersistenceRule_MIN = KeyValueStore_PersistenceRule_ON_WRITE;
const KeyValueStore_PersistenceRule KeyValueStore_PersistenceRule_PersistenceRule_MAX = KeyValueStore_PersistenceRule_LAZY;
const int KeyValueStore_PersistenceRule_PersistenceRule_ARRAYSIZE = KeyValueStore_PersistenceRule_PersistenceRule_MAX + 1;

const ::google::protobuf::EnumDescriptor* KeyValueStore_PersistenceRule_descriptor();
inline const ::std::string& KeyValueStore_PersistenceRule_Name(KeyValueStore_PersistenceRule value) {
  return ::google::protobuf::internal::NameOfEnum(
    KeyValueStore_PersistenceRule_descriptor(), value);
}
inline bool KeyValueStore_PersistenceRule_Parse(
    const ::std::string& name, KeyValueStore_PersistenceRule* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KeyValueStore_PersistenceRule>(
    KeyValueStore_PersistenceRule_descriptor(), name, value);
}
enum Tiering_EncryptionAlgorithm {
  Tiering_EncryptionAlgorithm_UNENCRYPTED = 0,
  Tiering_EncryptionAlgorithm_AES_128 = 1
};
bool Tiering_EncryptionAlgorithm_IsValid(int value);
const Tiering_EncryptionAlgorithm Tiering_EncryptionAlgorithm_EncryptionAlgorithm_MIN = Tiering_EncryptionAlgorithm_UNENCRYPTED;
const Tiering_EncryptionAlgorithm Tiering_EncryptionAlgorithm_EncryptionAlgorithm_MAX = Tiering_EncryptionAlgorithm_AES_128;
const int Tiering_EncryptionAlgorithm_EncryptionAlgorithm_ARRAYSIZE = Tiering_EncryptionAlgorithm_EncryptionAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* Tiering_EncryptionAlgorithm_descriptor();
inline const ::std::string& Tiering_EncryptionAlgorithm_Name(Tiering_EncryptionAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    Tiering_EncryptionAlgorithm_descriptor(), value);
}
inline bool Tiering_EncryptionAlgorithm_Parse(
    const ::std::string& name, Tiering_EncryptionAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Tiering_EncryptionAlgorithm>(
    Tiering_EncryptionAlgorithm_descriptor(), name, value);
}
enum Tiering_CompressionAlgorithm {
  Tiering_CompressionAlgorithm_UNCOMPRESSED = 0,
  Tiering_CompressionAlgorithm_ZIP = 1,
  Tiering_CompressionAlgorithm_SNAPPY = 2
};
bool Tiering_CompressionAlgorithm_IsValid(int value);
const Tiering_CompressionAlgorithm Tiering_CompressionAlgorithm_CompressionAlgorithm_MIN = Tiering_CompressionAlgorithm_UNCOMPRESSED;
const Tiering_CompressionAlgorithm Tiering_CompressionAlgorithm_CompressionAlgorithm_MAX = Tiering_CompressionAlgorithm_SNAPPY;
const int Tiering_CompressionAlgorithm_CompressionAlgorithm_ARRAYSIZE = Tiering_CompressionAlgorithm_CompressionAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* Tiering_CompressionAlgorithm_descriptor();
inline const ::std::string& Tiering_CompressionAlgorithm_Name(Tiering_CompressionAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    Tiering_CompressionAlgorithm_descriptor(), value);
}
inline bool Tiering_CompressionAlgorithm_Parse(
    const ::std::string& name, Tiering_CompressionAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Tiering_CompressionAlgorithm>(
    Tiering_CompressionAlgorithm_descriptor(), name, value);
}
enum Cloud_CloudAccessProtocol {
  Cloud_CloudAccessProtocol_LOCAL = 0,
  Cloud_CloudAccessProtocol_AMAZON_S3 = 1,
  Cloud_CloudAccessProtocol_GOOGLE_STORAGE_V1 = 2
};
bool Cloud_CloudAccessProtocol_IsValid(int value);
const Cloud_CloudAccessProtocol Cloud_CloudAccessProtocol_CloudAccessProtocol_MIN = Cloud_CloudAccessProtocol_LOCAL;
const Cloud_CloudAccessProtocol Cloud_CloudAccessProtocol_CloudAccessProtocol_MAX = Cloud_CloudAccessProtocol_GOOGLE_STORAGE_V1;
const int Cloud_CloudAccessProtocol_CloudAccessProtocol_ARRAYSIZE = Cloud_CloudAccessProtocol_CloudAccessProtocol_MAX + 1;

const ::google::protobuf::EnumDescriptor* Cloud_CloudAccessProtocol_descriptor();
inline const ::std::string& Cloud_CloudAccessProtocol_Name(Cloud_CloudAccessProtocol value) {
  return ::google::protobuf::internal::NameOfEnum(
    Cloud_CloudAccessProtocol_descriptor(), value);
}
inline bool Cloud_CloudAccessProtocol_Parse(
    const ::std::string& name, Cloud_CloudAccessProtocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Cloud_CloudAccessProtocol>(
    Cloud_CloudAccessProtocol_descriptor(), name, value);
}
// ===================================================================

class Config : public ::google::protobuf::Message {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  void Swap(Config* other);

  // implements Message ----------------------------------------------

  Config* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string uuid = 2;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 2;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional .pqfs.config.proto.Primary primary = 3;
  inline bool has_primary() const;
  inline void clear_primary();
  static const int kPrimaryFieldNumber = 3;
  inline const ::pqfs::config::proto::Primary& primary() const;
  inline ::pqfs::config::proto::Primary* mutable_primary();
  inline ::pqfs::config::proto::Primary* release_primary();
  inline void set_allocated_primary(::pqfs::config::proto::Primary* primary);

  // optional .pqfs.config.proto.KeyValueStore keyValueStore = 4;
  inline bool has_keyvaluestore() const;
  inline void clear_keyvaluestore();
  static const int kKeyValueStoreFieldNumber = 4;
  inline const ::pqfs::config::proto::KeyValueStore& keyvaluestore() const;
  inline ::pqfs::config::proto::KeyValueStore* mutable_keyvaluestore();
  inline ::pqfs::config::proto::KeyValueStore* release_keyvaluestore();
  inline void set_allocated_keyvaluestore(::pqfs::config::proto::KeyValueStore* keyvaluestore);

  // optional .pqfs.config.proto.Tiering tiering = 5;
  inline bool has_tiering() const;
  inline void clear_tiering();
  static const int kTieringFieldNumber = 5;
  inline const ::pqfs::config::proto::Tiering& tiering() const;
  inline ::pqfs::config::proto::Tiering* mutable_tiering();
  inline ::pqfs::config::proto::Tiering* release_tiering();
  inline void set_allocated_tiering(::pqfs::config::proto::Tiering* tiering);

  // optional .pqfs.config.proto.Cloud cloud = 6;
  inline bool has_cloud() const;
  inline void clear_cloud();
  static const int kCloudFieldNumber = 6;
  inline const ::pqfs::config::proto::Cloud& cloud() const;
  inline ::pqfs::config::proto::Cloud* mutable_cloud();
  inline ::pqfs::config::proto::Cloud* release_cloud();
  inline void set_allocated_cloud(::pqfs::config::proto::Cloud* cloud);

  // @@protoc_insertion_point(class_scope:pqfs.config.proto.Config)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_primary();
  inline void clear_has_primary();
  inline void set_has_keyvaluestore();
  inline void clear_has_keyvaluestore();
  inline void set_has_tiering();
  inline void clear_has_tiering();
  inline void set_has_cloud();
  inline void clear_has_cloud();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* uuid_;
  ::pqfs::config::proto::Primary* primary_;
  ::pqfs::config::proto::KeyValueStore* keyvaluestore_;
  ::pqfs::config::proto::Tiering* tiering_;
  ::pqfs::config::proto::Cloud* cloud_;
  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static Config* default_instance_;
};
// -------------------------------------------------------------------

class Primary : public ::google::protobuf::Message {
 public:
  Primary();
  virtual ~Primary();

  Primary(const Primary& from);

  inline Primary& operator=(const Primary& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Primary& default_instance();

  void Swap(Primary* other);

  // implements Message ----------------------------------------------

  Primary* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Primary& from);
  void MergeFrom(const Primary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string host = 1 [default = "localhost"];
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 1;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional int64 epoch = 2 [default = 1];
  inline bool has_epoch() const;
  inline void clear_epoch();
  static const int kEpochFieldNumber = 2;
  inline ::google::protobuf::int64 epoch() const;
  inline void set_epoch(::google::protobuf::int64 value);

  // optional int64 startTime = 3 [default = 0];
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::int64 starttime() const;
  inline void set_starttime(::google::protobuf::int64 value);

  // optional bool fuse_cache_enable = 4 [default = true];
  inline bool has_fuse_cache_enable() const;
  inline void clear_fuse_cache_enable();
  static const int kFuseCacheEnableFieldNumber = 4;
  inline bool fuse_cache_enable() const;
  inline void set_fuse_cache_enable(bool value);

  // optional bool fuse_direct_io = 5 [default = false];
  inline bool has_fuse_direct_io() const;
  inline void clear_fuse_direct_io();
  static const int kFuseDirectIoFieldNumber = 5;
  inline bool fuse_direct_io() const;
  inline void set_fuse_direct_io(bool value);

  // @@protoc_insertion_point(class_scope:pqfs.config.proto.Primary)
 private:
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_epoch();
  inline void clear_has_epoch();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_fuse_cache_enable();
  inline void clear_has_fuse_cache_enable();
  inline void set_has_fuse_direct_io();
  inline void clear_has_fuse_direct_io();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  static ::std::string* _default_host_;
  ::std::string* host_;
  ::google::protobuf::int64 epoch_;
  ::google::protobuf::int64 starttime_;
  bool fuse_cache_enable_;
  bool fuse_direct_io_;
  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static Primary* default_instance_;
};
// -------------------------------------------------------------------

class KeyValueStore : public ::google::protobuf::Message {
 public:
  KeyValueStore();
  virtual ~KeyValueStore();

  KeyValueStore(const KeyValueStore& from);

  inline KeyValueStore& operator=(const KeyValueStore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValueStore& default_instance();

  void Swap(KeyValueStore* other);

  // implements Message ----------------------------------------------

  KeyValueStore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyValueStore& from);
  void MergeFrom(const KeyValueStore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef KeyValueStore_Type Type;
  static const Type ROXDB = KeyValueStore_Type_ROXDB;
  static const Type LEVELDB = KeyValueStore_Type_LEVELDB;
  static const Type RAMCLOUD = KeyValueStore_Type_RAMCLOUD;
  static inline bool Type_IsValid(int value) {
    return KeyValueStore_Type_IsValid(value);
  }
  static const Type Type_MIN =
    KeyValueStore_Type_Type_MIN;
  static const Type Type_MAX =
    KeyValueStore_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    KeyValueStore_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return KeyValueStore_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return KeyValueStore_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return KeyValueStore_Type_Parse(name, value);
  }

  typedef KeyValueStore_PersistenceRule PersistenceRule;
  static const PersistenceRule ON_WRITE = KeyValueStore_PersistenceRule_ON_WRITE;
  static const PersistenceRule ON_CLOSE = KeyValueStore_PersistenceRule_ON_CLOSE;
  static const PersistenceRule LAZY = KeyValueStore_PersistenceRule_LAZY;
  static inline bool PersistenceRule_IsValid(int value) {
    return KeyValueStore_PersistenceRule_IsValid(value);
  }
  static const PersistenceRule PersistenceRule_MIN =
    KeyValueStore_PersistenceRule_PersistenceRule_MIN;
  static const PersistenceRule PersistenceRule_MAX =
    KeyValueStore_PersistenceRule_PersistenceRule_MAX;
  static const int PersistenceRule_ARRAYSIZE =
    KeyValueStore_PersistenceRule_PersistenceRule_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PersistenceRule_descriptor() {
    return KeyValueStore_PersistenceRule_descriptor();
  }
  static inline const ::std::string& PersistenceRule_Name(PersistenceRule value) {
    return KeyValueStore_PersistenceRule_Name(value);
  }
  static inline bool PersistenceRule_Parse(const ::std::string& name,
      PersistenceRule* value) {
    return KeyValueStore_PersistenceRule_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .pqfs.config.proto.KeyValueStore.Type type = 1 [default = LEVELDB];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pqfs::config::proto::KeyValueStore_Type type() const;
  inline void set_type(::pqfs::config::proto::KeyValueStore_Type value);

  // optional string filename = 2 [default = ""];
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional .pqfs.config.proto.KeyValueStore.PersistenceRule persistenceRule = 3 [default = LAZY];
  inline bool has_persistencerule() const;
  inline void clear_persistencerule();
  static const int kPersistenceRuleFieldNumber = 3;
  inline ::pqfs::config::proto::KeyValueStore_PersistenceRule persistencerule() const;
  inline void set_persistencerule(::pqfs::config::proto::KeyValueStore_PersistenceRule value);

  // optional int64 maxSizeBytes = 4 [default = 100000000];
  inline bool has_maxsizebytes() const;
  inline void clear_maxsizebytes();
  static const int kMaxSizeBytesFieldNumber = 4;
  inline ::google::protobuf::int64 maxsizebytes() const;
  inline void set_maxsizebytes(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pqfs.config.proto.KeyValueStore)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_persistencerule();
  inline void clear_has_persistencerule();
  inline void set_has_maxsizebytes();
  inline void clear_has_maxsizebytes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* filename_;
  int type_;
  int persistencerule_;
  ::google::protobuf::int64 maxsizebytes_;
  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static KeyValueStore* default_instance_;
};
// -------------------------------------------------------------------

class Tiering : public ::google::protobuf::Message {
 public:
  Tiering();
  virtual ~Tiering();

  Tiering(const Tiering& from);

  inline Tiering& operator=(const Tiering& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tiering& default_instance();

  void Swap(Tiering* other);

  // implements Message ----------------------------------------------

  Tiering* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tiering& from);
  void MergeFrom(const Tiering& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Tiering_EncryptionAlgorithm EncryptionAlgorithm;
  static const EncryptionAlgorithm UNENCRYPTED = Tiering_EncryptionAlgorithm_UNENCRYPTED;
  static const EncryptionAlgorithm AES_128 = Tiering_EncryptionAlgorithm_AES_128;
  static inline bool EncryptionAlgorithm_IsValid(int value) {
    return Tiering_EncryptionAlgorithm_IsValid(value);
  }
  static const EncryptionAlgorithm EncryptionAlgorithm_MIN =
    Tiering_EncryptionAlgorithm_EncryptionAlgorithm_MIN;
  static const EncryptionAlgorithm EncryptionAlgorithm_MAX =
    Tiering_EncryptionAlgorithm_EncryptionAlgorithm_MAX;
  static const int EncryptionAlgorithm_ARRAYSIZE =
    Tiering_EncryptionAlgorithm_EncryptionAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EncryptionAlgorithm_descriptor() {
    return Tiering_EncryptionAlgorithm_descriptor();
  }
  static inline const ::std::string& EncryptionAlgorithm_Name(EncryptionAlgorithm value) {
    return Tiering_EncryptionAlgorithm_Name(value);
  }
  static inline bool EncryptionAlgorithm_Parse(const ::std::string& name,
      EncryptionAlgorithm* value) {
    return Tiering_EncryptionAlgorithm_Parse(name, value);
  }

  typedef Tiering_CompressionAlgorithm CompressionAlgorithm;
  static const CompressionAlgorithm UNCOMPRESSED = Tiering_CompressionAlgorithm_UNCOMPRESSED;
  static const CompressionAlgorithm ZIP = Tiering_CompressionAlgorithm_ZIP;
  static const CompressionAlgorithm SNAPPY = Tiering_CompressionAlgorithm_SNAPPY;
  static inline bool CompressionAlgorithm_IsValid(int value) {
    return Tiering_CompressionAlgorithm_IsValid(value);
  }
  static const CompressionAlgorithm CompressionAlgorithm_MIN =
    Tiering_CompressionAlgorithm_CompressionAlgorithm_MIN;
  static const CompressionAlgorithm CompressionAlgorithm_MAX =
    Tiering_CompressionAlgorithm_CompressionAlgorithm_MAX;
  static const int CompressionAlgorithm_ARRAYSIZE =
    Tiering_CompressionAlgorithm_CompressionAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CompressionAlgorithm_descriptor() {
    return Tiering_CompressionAlgorithm_descriptor();
  }
  static inline const ::std::string& CompressionAlgorithm_Name(CompressionAlgorithm value) {
    return Tiering_CompressionAlgorithm_Name(value);
  }
  static inline bool CompressionAlgorithm_Parse(const ::std::string& name,
      CompressionAlgorithm* value) {
    return Tiering_CompressionAlgorithm_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string cacheDir = 1;
  inline bool has_cachedir() const;
  inline void clear_cachedir();
  static const int kCacheDirFieldNumber = 1;
  inline const ::std::string& cachedir() const;
  inline void set_cachedir(const ::std::string& value);
  inline void set_cachedir(const char* value);
  inline void set_cachedir(const char* value, size_t size);
  inline ::std::string* mutable_cachedir();
  inline ::std::string* release_cachedir();
  inline void set_allocated_cachedir(::std::string* cachedir);

  // optional .pqfs.config.proto.Tiering.EncryptionAlgorithm encryption = 2 [default = UNENCRYPTED];
  inline bool has_encryption() const;
  inline void clear_encryption();
  static const int kEncryptionFieldNumber = 2;
  inline ::pqfs::config::proto::Tiering_EncryptionAlgorithm encryption() const;
  inline void set_encryption(::pqfs::config::proto::Tiering_EncryptionAlgorithm value);

  // optional string encryptionKey = 3 [default = ""];
  inline bool has_encryptionkey() const;
  inline void clear_encryptionkey();
  static const int kEncryptionKeyFieldNumber = 3;
  inline const ::std::string& encryptionkey() const;
  inline void set_encryptionkey(const ::std::string& value);
  inline void set_encryptionkey(const char* value);
  inline void set_encryptionkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptionkey();
  inline ::std::string* release_encryptionkey();
  inline void set_allocated_encryptionkey(::std::string* encryptionkey);

  // optional .pqfs.config.proto.Tiering.CompressionAlgorithm compression = 4 [default = ZIP];
  inline bool has_compression() const;
  inline void clear_compression();
  static const int kCompressionFieldNumber = 4;
  inline ::pqfs::config::proto::Tiering_CompressionAlgorithm compression() const;
  inline void set_compression(::pqfs::config::proto::Tiering_CompressionAlgorithm value);

  // optional int64 mirrorLagSeconds = 5 [default = 0];
  inline bool has_mirrorlagseconds() const;
  inline void clear_mirrorlagseconds();
  static const int kMirrorLagSecondsFieldNumber = 5;
  inline ::google::protobuf::int64 mirrorlagseconds() const;
  inline void set_mirrorlagseconds(::google::protobuf::int64 value);

  // optional int64 cacheSizeBytes = 6 [default = 100000000];
  inline bool has_cachesizebytes() const;
  inline void clear_cachesizebytes();
  static const int kCacheSizeBytesFieldNumber = 6;
  inline ::google::protobuf::int64 cachesizebytes() const;
  inline void set_cachesizebytes(::google::protobuf::int64 value);

  // optional int32 cacheFreePercent = 7 [default = 20];
  inline bool has_cachefreepercent() const;
  inline void clear_cachefreepercent();
  static const int kCacheFreePercentFieldNumber = 7;
  inline ::google::protobuf::int32 cachefreepercent() const;
  inline void set_cachefreepercent(::google::protobuf::int32 value);

  // optional int64 maxObjectSizeBytes = 8 [default = 1000000000];
  inline bool has_maxobjectsizebytes() const;
  inline void clear_maxobjectsizebytes();
  static const int kMaxObjectSizeBytesFieldNumber = 8;
  inline ::google::protobuf::int64 maxobjectsizebytes() const;
  inline void set_maxobjectsizebytes(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pqfs.config.proto.Tiering)
 private:
  inline void set_has_cachedir();
  inline void clear_has_cachedir();
  inline void set_has_encryption();
  inline void clear_has_encryption();
  inline void set_has_encryptionkey();
  inline void clear_has_encryptionkey();
  inline void set_has_compression();
  inline void clear_has_compression();
  inline void set_has_mirrorlagseconds();
  inline void clear_has_mirrorlagseconds();
  inline void set_has_cachesizebytes();
  inline void clear_has_cachesizebytes();
  inline void set_has_cachefreepercent();
  inline void clear_has_cachefreepercent();
  inline void set_has_maxobjectsizebytes();
  inline void clear_has_maxobjectsizebytes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* cachedir_;
  ::std::string* encryptionkey_;
  int encryption_;
  int compression_;
  ::google::protobuf::int64 mirrorlagseconds_;
  ::google::protobuf::int64 cachesizebytes_;
  ::google::protobuf::int64 maxobjectsizebytes_;
  ::google::protobuf::int32 cachefreepercent_;
  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static Tiering* default_instance_;
};
// -------------------------------------------------------------------

class Cloud : public ::google::protobuf::Message {
 public:
  Cloud();
  virtual ~Cloud();

  Cloud(const Cloud& from);

  inline Cloud& operator=(const Cloud& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cloud& default_instance();

  void Swap(Cloud* other);

  // implements Message ----------------------------------------------

  Cloud* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cloud& from);
  void MergeFrom(const Cloud& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Cloud_CloudAccessProtocol CloudAccessProtocol;
  static const CloudAccessProtocol LOCAL = Cloud_CloudAccessProtocol_LOCAL;
  static const CloudAccessProtocol AMAZON_S3 = Cloud_CloudAccessProtocol_AMAZON_S3;
  static const CloudAccessProtocol GOOGLE_STORAGE_V1 = Cloud_CloudAccessProtocol_GOOGLE_STORAGE_V1;
  static inline bool CloudAccessProtocol_IsValid(int value) {
    return Cloud_CloudAccessProtocol_IsValid(value);
  }
  static const CloudAccessProtocol CloudAccessProtocol_MIN =
    Cloud_CloudAccessProtocol_CloudAccessProtocol_MIN;
  static const CloudAccessProtocol CloudAccessProtocol_MAX =
    Cloud_CloudAccessProtocol_CloudAccessProtocol_MAX;
  static const int CloudAccessProtocol_ARRAYSIZE =
    Cloud_CloudAccessProtocol_CloudAccessProtocol_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CloudAccessProtocol_descriptor() {
    return Cloud_CloudAccessProtocol_descriptor();
  }
  static inline const ::std::string& CloudAccessProtocol_Name(CloudAccessProtocol value) {
    return Cloud_CloudAccessProtocol_Name(value);
  }
  static inline bool CloudAccessProtocol_Parse(const ::std::string& name,
      CloudAccessProtocol* value) {
    return Cloud_CloudAccessProtocol_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .pqfs.config.proto.Cloud.CloudAccessProtocol protocol = 1 [default = AMAZON_S3];
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 1;
  inline ::pqfs::config::proto::Cloud_CloudAccessProtocol protocol() const;
  inline void set_protocol(::pqfs::config::proto::Cloud_CloudAccessProtocol value);

  // optional string endpoint = 2;
  inline bool has_endpoint() const;
  inline void clear_endpoint();
  static const int kEndpointFieldNumber = 2;
  inline const ::std::string& endpoint() const;
  inline void set_endpoint(const ::std::string& value);
  inline void set_endpoint(const char* value);
  inline void set_endpoint(const char* value, size_t size);
  inline ::std::string* mutable_endpoint();
  inline ::std::string* release_endpoint();
  inline void set_allocated_endpoint(::std::string* endpoint);

  // @@protoc_insertion_point(class_scope:pqfs.config.proto.Cloud)
 private:
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_endpoint();
  inline void clear_has_endpoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* endpoint_;
  int protocol_;
  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static Cloud* default_instance_;
};
// ===================================================================


// ===================================================================

// Config

// optional string name = 1;
inline bool Config::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Config::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Config::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Config::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Config::name() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Config.name)
  return *name_;
}
inline void Config::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Config.name)
}
inline void Config::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pqfs.config.proto.Config.name)
}
inline void Config::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pqfs.config.proto.Config.name)
}
inline ::std::string* Config::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pqfs.config.proto.Config.name)
  return name_;
}
inline ::std::string* Config::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Config::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pqfs.config.proto.Config.name)
}

// optional string uuid = 2;
inline bool Config::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Config::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Config::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Config::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& Config::uuid() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Config.uuid)
  return *uuid_;
}
inline void Config::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Config.uuid)
}
inline void Config::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:pqfs.config.proto.Config.uuid)
}
inline void Config::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pqfs.config.proto.Config.uuid)
}
inline ::std::string* Config::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pqfs.config.proto.Config.uuid)
  return uuid_;
}
inline ::std::string* Config::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Config::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pqfs.config.proto.Config.uuid)
}

// optional .pqfs.config.proto.Primary primary = 3;
inline bool Config::has_primary() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Config::set_has_primary() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Config::clear_has_primary() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Config::clear_primary() {
  if (primary_ != NULL) primary_->::pqfs::config::proto::Primary::Clear();
  clear_has_primary();
}
inline const ::pqfs::config::proto::Primary& Config::primary() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Config.primary)
  return primary_ != NULL ? *primary_ : *default_instance_->primary_;
}
inline ::pqfs::config::proto::Primary* Config::mutable_primary() {
  set_has_primary();
  if (primary_ == NULL) primary_ = new ::pqfs::config::proto::Primary;
  // @@protoc_insertion_point(field_mutable:pqfs.config.proto.Config.primary)
  return primary_;
}
inline ::pqfs::config::proto::Primary* Config::release_primary() {
  clear_has_primary();
  ::pqfs::config::proto::Primary* temp = primary_;
  primary_ = NULL;
  return temp;
}
inline void Config::set_allocated_primary(::pqfs::config::proto::Primary* primary) {
  delete primary_;
  primary_ = primary;
  if (primary) {
    set_has_primary();
  } else {
    clear_has_primary();
  }
  // @@protoc_insertion_point(field_set_allocated:pqfs.config.proto.Config.primary)
}

// optional .pqfs.config.proto.KeyValueStore keyValueStore = 4;
inline bool Config::has_keyvaluestore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Config::set_has_keyvaluestore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Config::clear_has_keyvaluestore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Config::clear_keyvaluestore() {
  if (keyvaluestore_ != NULL) keyvaluestore_->::pqfs::config::proto::KeyValueStore::Clear();
  clear_has_keyvaluestore();
}
inline const ::pqfs::config::proto::KeyValueStore& Config::keyvaluestore() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Config.keyValueStore)
  return keyvaluestore_ != NULL ? *keyvaluestore_ : *default_instance_->keyvaluestore_;
}
inline ::pqfs::config::proto::KeyValueStore* Config::mutable_keyvaluestore() {
  set_has_keyvaluestore();
  if (keyvaluestore_ == NULL) keyvaluestore_ = new ::pqfs::config::proto::KeyValueStore;
  // @@protoc_insertion_point(field_mutable:pqfs.config.proto.Config.keyValueStore)
  return keyvaluestore_;
}
inline ::pqfs::config::proto::KeyValueStore* Config::release_keyvaluestore() {
  clear_has_keyvaluestore();
  ::pqfs::config::proto::KeyValueStore* temp = keyvaluestore_;
  keyvaluestore_ = NULL;
  return temp;
}
inline void Config::set_allocated_keyvaluestore(::pqfs::config::proto::KeyValueStore* keyvaluestore) {
  delete keyvaluestore_;
  keyvaluestore_ = keyvaluestore;
  if (keyvaluestore) {
    set_has_keyvaluestore();
  } else {
    clear_has_keyvaluestore();
  }
  // @@protoc_insertion_point(field_set_allocated:pqfs.config.proto.Config.keyValueStore)
}

// optional .pqfs.config.proto.Tiering tiering = 5;
inline bool Config::has_tiering() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Config::set_has_tiering() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Config::clear_has_tiering() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Config::clear_tiering() {
  if (tiering_ != NULL) tiering_->::pqfs::config::proto::Tiering::Clear();
  clear_has_tiering();
}
inline const ::pqfs::config::proto::Tiering& Config::tiering() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Config.tiering)
  return tiering_ != NULL ? *tiering_ : *default_instance_->tiering_;
}
inline ::pqfs::config::proto::Tiering* Config::mutable_tiering() {
  set_has_tiering();
  if (tiering_ == NULL) tiering_ = new ::pqfs::config::proto::Tiering;
  // @@protoc_insertion_point(field_mutable:pqfs.config.proto.Config.tiering)
  return tiering_;
}
inline ::pqfs::config::proto::Tiering* Config::release_tiering() {
  clear_has_tiering();
  ::pqfs::config::proto::Tiering* temp = tiering_;
  tiering_ = NULL;
  return temp;
}
inline void Config::set_allocated_tiering(::pqfs::config::proto::Tiering* tiering) {
  delete tiering_;
  tiering_ = tiering;
  if (tiering) {
    set_has_tiering();
  } else {
    clear_has_tiering();
  }
  // @@protoc_insertion_point(field_set_allocated:pqfs.config.proto.Config.tiering)
}

// optional .pqfs.config.proto.Cloud cloud = 6;
inline bool Config::has_cloud() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Config::set_has_cloud() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Config::clear_has_cloud() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Config::clear_cloud() {
  if (cloud_ != NULL) cloud_->::pqfs::config::proto::Cloud::Clear();
  clear_has_cloud();
}
inline const ::pqfs::config::proto::Cloud& Config::cloud() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Config.cloud)
  return cloud_ != NULL ? *cloud_ : *default_instance_->cloud_;
}
inline ::pqfs::config::proto::Cloud* Config::mutable_cloud() {
  set_has_cloud();
  if (cloud_ == NULL) cloud_ = new ::pqfs::config::proto::Cloud;
  // @@protoc_insertion_point(field_mutable:pqfs.config.proto.Config.cloud)
  return cloud_;
}
inline ::pqfs::config::proto::Cloud* Config::release_cloud() {
  clear_has_cloud();
  ::pqfs::config::proto::Cloud* temp = cloud_;
  cloud_ = NULL;
  return temp;
}
inline void Config::set_allocated_cloud(::pqfs::config::proto::Cloud* cloud) {
  delete cloud_;
  cloud_ = cloud;
  if (cloud) {
    set_has_cloud();
  } else {
    clear_has_cloud();
  }
  // @@protoc_insertion_point(field_set_allocated:pqfs.config.proto.Config.cloud)
}

// -------------------------------------------------------------------

// Primary

// optional string host = 1 [default = "localhost"];
inline bool Primary::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Primary::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Primary::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Primary::clear_host() {
  if (host_ != _default_host_) {
    host_->assign(*_default_host_);
  }
  clear_has_host();
}
inline const ::std::string& Primary::host() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Primary.host)
  return *host_;
}
inline void Primary::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(value);
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Primary.host)
}
inline void Primary::set_host(const char* value) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(value);
  // @@protoc_insertion_point(field_set_char:pqfs.config.proto.Primary.host)
}
inline void Primary::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pqfs.config.proto.Primary.host)
}
inline ::std::string* Primary::mutable_host() {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string(*_default_host_);
  }
  // @@protoc_insertion_point(field_mutable:pqfs.config.proto.Primary.host)
  return host_;
}
inline ::std::string* Primary::release_host() {
  clear_has_host();
  if (host_ == _default_host_) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(_default_host_);
    return temp;
  }
}
inline void Primary::set_allocated_host(::std::string* host) {
  if (host_ != _default_host_) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(_default_host_);
  }
  // @@protoc_insertion_point(field_set_allocated:pqfs.config.proto.Primary.host)
}

// optional int64 epoch = 2 [default = 1];
inline bool Primary::has_epoch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Primary::set_has_epoch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Primary::clear_has_epoch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Primary::clear_epoch() {
  epoch_ = GOOGLE_LONGLONG(1);
  clear_has_epoch();
}
inline ::google::protobuf::int64 Primary::epoch() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Primary.epoch)
  return epoch_;
}
inline void Primary::set_epoch(::google::protobuf::int64 value) {
  set_has_epoch();
  epoch_ = value;
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Primary.epoch)
}

// optional int64 startTime = 3 [default = 0];
inline bool Primary::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Primary::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Primary::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Primary::clear_starttime() {
  starttime_ = GOOGLE_LONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::int64 Primary::starttime() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Primary.startTime)
  return starttime_;
}
inline void Primary::set_starttime(::google::protobuf::int64 value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Primary.startTime)
}

// optional bool fuse_cache_enable = 4 [default = true];
inline bool Primary::has_fuse_cache_enable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Primary::set_has_fuse_cache_enable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Primary::clear_has_fuse_cache_enable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Primary::clear_fuse_cache_enable() {
  fuse_cache_enable_ = true;
  clear_has_fuse_cache_enable();
}
inline bool Primary::fuse_cache_enable() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Primary.fuse_cache_enable)
  return fuse_cache_enable_;
}
inline void Primary::set_fuse_cache_enable(bool value) {
  set_has_fuse_cache_enable();
  fuse_cache_enable_ = value;
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Primary.fuse_cache_enable)
}

// optional bool fuse_direct_io = 5 [default = false];
inline bool Primary::has_fuse_direct_io() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Primary::set_has_fuse_direct_io() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Primary::clear_has_fuse_direct_io() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Primary::clear_fuse_direct_io() {
  fuse_direct_io_ = false;
  clear_has_fuse_direct_io();
}
inline bool Primary::fuse_direct_io() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Primary.fuse_direct_io)
  return fuse_direct_io_;
}
inline void Primary::set_fuse_direct_io(bool value) {
  set_has_fuse_direct_io();
  fuse_direct_io_ = value;
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Primary.fuse_direct_io)
}

// -------------------------------------------------------------------

// KeyValueStore

// optional .pqfs.config.proto.KeyValueStore.Type type = 1 [default = LEVELDB];
inline bool KeyValueStore::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyValueStore::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyValueStore::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyValueStore::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pqfs::config::proto::KeyValueStore_Type KeyValueStore::type() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.KeyValueStore.type)
  return static_cast< ::pqfs::config::proto::KeyValueStore_Type >(type_);
}
inline void KeyValueStore::set_type(::pqfs::config::proto::KeyValueStore_Type value) {
  assert(::pqfs::config::proto::KeyValueStore_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pqfs.config.proto.KeyValueStore.type)
}

// optional string filename = 2 [default = ""];
inline bool KeyValueStore::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyValueStore::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyValueStore::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyValueStore::clear_filename() {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& KeyValueStore::filename() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.KeyValueStore.filename)
  return *filename_;
}
inline void KeyValueStore::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set:pqfs.config.proto.KeyValueStore.filename)
}
inline void KeyValueStore::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set_char:pqfs.config.proto.KeyValueStore.filename)
}
inline void KeyValueStore::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pqfs.config.proto.KeyValueStore.filename)
}
inline ::std::string* KeyValueStore::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pqfs.config.proto.KeyValueStore.filename)
  return filename_;
}
inline ::std::string* KeyValueStore::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KeyValueStore::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pqfs.config.proto.KeyValueStore.filename)
}

// optional .pqfs.config.proto.KeyValueStore.PersistenceRule persistenceRule = 3 [default = LAZY];
inline bool KeyValueStore::has_persistencerule() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeyValueStore::set_has_persistencerule() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeyValueStore::clear_has_persistencerule() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeyValueStore::clear_persistencerule() {
  persistencerule_ = 2;
  clear_has_persistencerule();
}
inline ::pqfs::config::proto::KeyValueStore_PersistenceRule KeyValueStore::persistencerule() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.KeyValueStore.persistenceRule)
  return static_cast< ::pqfs::config::proto::KeyValueStore_PersistenceRule >(persistencerule_);
}
inline void KeyValueStore::set_persistencerule(::pqfs::config::proto::KeyValueStore_PersistenceRule value) {
  assert(::pqfs::config::proto::KeyValueStore_PersistenceRule_IsValid(value));
  set_has_persistencerule();
  persistencerule_ = value;
  // @@protoc_insertion_point(field_set:pqfs.config.proto.KeyValueStore.persistenceRule)
}

// optional int64 maxSizeBytes = 4 [default = 100000000];
inline bool KeyValueStore::has_maxsizebytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KeyValueStore::set_has_maxsizebytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KeyValueStore::clear_has_maxsizebytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KeyValueStore::clear_maxsizebytes() {
  maxsizebytes_ = GOOGLE_LONGLONG(100000000);
  clear_has_maxsizebytes();
}
inline ::google::protobuf::int64 KeyValueStore::maxsizebytes() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.KeyValueStore.maxSizeBytes)
  return maxsizebytes_;
}
inline void KeyValueStore::set_maxsizebytes(::google::protobuf::int64 value) {
  set_has_maxsizebytes();
  maxsizebytes_ = value;
  // @@protoc_insertion_point(field_set:pqfs.config.proto.KeyValueStore.maxSizeBytes)
}

// -------------------------------------------------------------------

// Tiering

// optional string cacheDir = 1;
inline bool Tiering::has_cachedir() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tiering::set_has_cachedir() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tiering::clear_has_cachedir() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tiering::clear_cachedir() {
  if (cachedir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cachedir_->clear();
  }
  clear_has_cachedir();
}
inline const ::std::string& Tiering::cachedir() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Tiering.cacheDir)
  return *cachedir_;
}
inline void Tiering::set_cachedir(const ::std::string& value) {
  set_has_cachedir();
  if (cachedir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cachedir_ = new ::std::string;
  }
  cachedir_->assign(value);
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Tiering.cacheDir)
}
inline void Tiering::set_cachedir(const char* value) {
  set_has_cachedir();
  if (cachedir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cachedir_ = new ::std::string;
  }
  cachedir_->assign(value);
  // @@protoc_insertion_point(field_set_char:pqfs.config.proto.Tiering.cacheDir)
}
inline void Tiering::set_cachedir(const char* value, size_t size) {
  set_has_cachedir();
  if (cachedir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cachedir_ = new ::std::string;
  }
  cachedir_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pqfs.config.proto.Tiering.cacheDir)
}
inline ::std::string* Tiering::mutable_cachedir() {
  set_has_cachedir();
  if (cachedir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cachedir_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pqfs.config.proto.Tiering.cacheDir)
  return cachedir_;
}
inline ::std::string* Tiering::release_cachedir() {
  clear_has_cachedir();
  if (cachedir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cachedir_;
    cachedir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Tiering::set_allocated_cachedir(::std::string* cachedir) {
  if (cachedir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cachedir_;
  }
  if (cachedir) {
    set_has_cachedir();
    cachedir_ = cachedir;
  } else {
    clear_has_cachedir();
    cachedir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pqfs.config.proto.Tiering.cacheDir)
}

// optional .pqfs.config.proto.Tiering.EncryptionAlgorithm encryption = 2 [default = UNENCRYPTED];
inline bool Tiering::has_encryption() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Tiering::set_has_encryption() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Tiering::clear_has_encryption() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Tiering::clear_encryption() {
  encryption_ = 0;
  clear_has_encryption();
}
inline ::pqfs::config::proto::Tiering_EncryptionAlgorithm Tiering::encryption() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Tiering.encryption)
  return static_cast< ::pqfs::config::proto::Tiering_EncryptionAlgorithm >(encryption_);
}
inline void Tiering::set_encryption(::pqfs::config::proto::Tiering_EncryptionAlgorithm value) {
  assert(::pqfs::config::proto::Tiering_EncryptionAlgorithm_IsValid(value));
  set_has_encryption();
  encryption_ = value;
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Tiering.encryption)
}

// optional string encryptionKey = 3 [default = ""];
inline bool Tiering::has_encryptionkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Tiering::set_has_encryptionkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Tiering::clear_has_encryptionkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Tiering::clear_encryptionkey() {
  if (encryptionkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryptionkey_->clear();
  }
  clear_has_encryptionkey();
}
inline const ::std::string& Tiering::encryptionkey() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Tiering.encryptionKey)
  return *encryptionkey_;
}
inline void Tiering::set_encryptionkey(const ::std::string& value) {
  set_has_encryptionkey();
  if (encryptionkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryptionkey_ = new ::std::string;
  }
  encryptionkey_->assign(value);
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Tiering.encryptionKey)
}
inline void Tiering::set_encryptionkey(const char* value) {
  set_has_encryptionkey();
  if (encryptionkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryptionkey_ = new ::std::string;
  }
  encryptionkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:pqfs.config.proto.Tiering.encryptionKey)
}
inline void Tiering::set_encryptionkey(const char* value, size_t size) {
  set_has_encryptionkey();
  if (encryptionkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryptionkey_ = new ::std::string;
  }
  encryptionkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pqfs.config.proto.Tiering.encryptionKey)
}
inline ::std::string* Tiering::mutable_encryptionkey() {
  set_has_encryptionkey();
  if (encryptionkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryptionkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pqfs.config.proto.Tiering.encryptionKey)
  return encryptionkey_;
}
inline ::std::string* Tiering::release_encryptionkey() {
  clear_has_encryptionkey();
  if (encryptionkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = encryptionkey_;
    encryptionkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Tiering::set_allocated_encryptionkey(::std::string* encryptionkey) {
  if (encryptionkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encryptionkey_;
  }
  if (encryptionkey) {
    set_has_encryptionkey();
    encryptionkey_ = encryptionkey;
  } else {
    clear_has_encryptionkey();
    encryptionkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pqfs.config.proto.Tiering.encryptionKey)
}

// optional .pqfs.config.proto.Tiering.CompressionAlgorithm compression = 4 [default = ZIP];
inline bool Tiering::has_compression() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Tiering::set_has_compression() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Tiering::clear_has_compression() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Tiering::clear_compression() {
  compression_ = 1;
  clear_has_compression();
}
inline ::pqfs::config::proto::Tiering_CompressionAlgorithm Tiering::compression() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Tiering.compression)
  return static_cast< ::pqfs::config::proto::Tiering_CompressionAlgorithm >(compression_);
}
inline void Tiering::set_compression(::pqfs::config::proto::Tiering_CompressionAlgorithm value) {
  assert(::pqfs::config::proto::Tiering_CompressionAlgorithm_IsValid(value));
  set_has_compression();
  compression_ = value;
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Tiering.compression)
}

// optional int64 mirrorLagSeconds = 5 [default = 0];
inline bool Tiering::has_mirrorlagseconds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Tiering::set_has_mirrorlagseconds() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Tiering::clear_has_mirrorlagseconds() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Tiering::clear_mirrorlagseconds() {
  mirrorlagseconds_ = GOOGLE_LONGLONG(0);
  clear_has_mirrorlagseconds();
}
inline ::google::protobuf::int64 Tiering::mirrorlagseconds() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Tiering.mirrorLagSeconds)
  return mirrorlagseconds_;
}
inline void Tiering::set_mirrorlagseconds(::google::protobuf::int64 value) {
  set_has_mirrorlagseconds();
  mirrorlagseconds_ = value;
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Tiering.mirrorLagSeconds)
}

// optional int64 cacheSizeBytes = 6 [default = 100000000];
inline bool Tiering::has_cachesizebytes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Tiering::set_has_cachesizebytes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Tiering::clear_has_cachesizebytes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Tiering::clear_cachesizebytes() {
  cachesizebytes_ = GOOGLE_LONGLONG(100000000);
  clear_has_cachesizebytes();
}
inline ::google::protobuf::int64 Tiering::cachesizebytes() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Tiering.cacheSizeBytes)
  return cachesizebytes_;
}
inline void Tiering::set_cachesizebytes(::google::protobuf::int64 value) {
  set_has_cachesizebytes();
  cachesizebytes_ = value;
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Tiering.cacheSizeBytes)
}

// optional int32 cacheFreePercent = 7 [default = 20];
inline bool Tiering::has_cachefreepercent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Tiering::set_has_cachefreepercent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Tiering::clear_has_cachefreepercent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Tiering::clear_cachefreepercent() {
  cachefreepercent_ = 20;
  clear_has_cachefreepercent();
}
inline ::google::protobuf::int32 Tiering::cachefreepercent() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Tiering.cacheFreePercent)
  return cachefreepercent_;
}
inline void Tiering::set_cachefreepercent(::google::protobuf::int32 value) {
  set_has_cachefreepercent();
  cachefreepercent_ = value;
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Tiering.cacheFreePercent)
}

// optional int64 maxObjectSizeBytes = 8 [default = 1000000000];
inline bool Tiering::has_maxobjectsizebytes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Tiering::set_has_maxobjectsizebytes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Tiering::clear_has_maxobjectsizebytes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Tiering::clear_maxobjectsizebytes() {
  maxobjectsizebytes_ = GOOGLE_LONGLONG(1000000000);
  clear_has_maxobjectsizebytes();
}
inline ::google::protobuf::int64 Tiering::maxobjectsizebytes() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Tiering.maxObjectSizeBytes)
  return maxobjectsizebytes_;
}
inline void Tiering::set_maxobjectsizebytes(::google::protobuf::int64 value) {
  set_has_maxobjectsizebytes();
  maxobjectsizebytes_ = value;
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Tiering.maxObjectSizeBytes)
}

// -------------------------------------------------------------------

// Cloud

// optional .pqfs.config.proto.Cloud.CloudAccessProtocol protocol = 1 [default = AMAZON_S3];
inline bool Cloud::has_protocol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cloud::set_has_protocol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cloud::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cloud::clear_protocol() {
  protocol_ = 1;
  clear_has_protocol();
}
inline ::pqfs::config::proto::Cloud_CloudAccessProtocol Cloud::protocol() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Cloud.protocol)
  return static_cast< ::pqfs::config::proto::Cloud_CloudAccessProtocol >(protocol_);
}
inline void Cloud::set_protocol(::pqfs::config::proto::Cloud_CloudAccessProtocol value) {
  assert(::pqfs::config::proto::Cloud_CloudAccessProtocol_IsValid(value));
  set_has_protocol();
  protocol_ = value;
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Cloud.protocol)
}

// optional string endpoint = 2;
inline bool Cloud::has_endpoint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cloud::set_has_endpoint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cloud::clear_has_endpoint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cloud::clear_endpoint() {
  if (endpoint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endpoint_->clear();
  }
  clear_has_endpoint();
}
inline const ::std::string& Cloud::endpoint() const {
  // @@protoc_insertion_point(field_get:pqfs.config.proto.Cloud.endpoint)
  return *endpoint_;
}
inline void Cloud::set_endpoint(const ::std::string& value) {
  set_has_endpoint();
  if (endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endpoint_ = new ::std::string;
  }
  endpoint_->assign(value);
  // @@protoc_insertion_point(field_set:pqfs.config.proto.Cloud.endpoint)
}
inline void Cloud::set_endpoint(const char* value) {
  set_has_endpoint();
  if (endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endpoint_ = new ::std::string;
  }
  endpoint_->assign(value);
  // @@protoc_insertion_point(field_set_char:pqfs.config.proto.Cloud.endpoint)
}
inline void Cloud::set_endpoint(const char* value, size_t size) {
  set_has_endpoint();
  if (endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endpoint_ = new ::std::string;
  }
  endpoint_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pqfs.config.proto.Cloud.endpoint)
}
inline ::std::string* Cloud::mutable_endpoint() {
  set_has_endpoint();
  if (endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endpoint_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pqfs.config.proto.Cloud.endpoint)
  return endpoint_;
}
inline ::std::string* Cloud::release_endpoint() {
  clear_has_endpoint();
  if (endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = endpoint_;
    endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Cloud::set_allocated_endpoint(::std::string* endpoint) {
  if (endpoint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete endpoint_;
  }
  if (endpoint) {
    set_has_endpoint();
    endpoint_ = endpoint;
  } else {
    clear_has_endpoint();
    endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pqfs.config.proto.Cloud.endpoint)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace config
}  // namespace pqfs

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pqfs::config::proto::KeyValueStore_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pqfs::config::proto::KeyValueStore_Type>() {
  return ::pqfs::config::proto::KeyValueStore_Type_descriptor();
}
template <> struct is_proto_enum< ::pqfs::config::proto::KeyValueStore_PersistenceRule> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pqfs::config::proto::KeyValueStore_PersistenceRule>() {
  return ::pqfs::config::proto::KeyValueStore_PersistenceRule_descriptor();
}
template <> struct is_proto_enum< ::pqfs::config::proto::Tiering_EncryptionAlgorithm> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pqfs::config::proto::Tiering_EncryptionAlgorithm>() {
  return ::pqfs::config::proto::Tiering_EncryptionAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::pqfs::config::proto::Tiering_CompressionAlgorithm> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pqfs::config::proto::Tiering_CompressionAlgorithm>() {
  return ::pqfs::config::proto::Tiering_CompressionAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::pqfs::config::proto::Cloud_CloudAccessProtocol> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pqfs::config::proto::Cloud_CloudAccessProtocol>() {
  return ::pqfs::config::proto::Cloud_CloudAccessProtocol_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_config_2eproto__INCLUDED
