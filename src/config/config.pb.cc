// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace pqfs {
namespace config {
namespace proto {

namespace {

const ::google::protobuf::Descriptor* Config_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Config_reflection_ = NULL;
const ::google::protobuf::Descriptor* Primary_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Primary_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeyValueStore_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeyValueStore_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* KeyValueStore_Type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* KeyValueStore_PersistenceRule_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Tiering_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Tiering_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Tiering_EncryptionAlgorithm_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Tiering_CompressionAlgorithm_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Cloud_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Cloud_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Cloud_CloudAccessProtocol_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_config_2eproto() {
  protobuf_AddDesc_config_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "config.proto");
  GOOGLE_CHECK(file != NULL);
  Config_descriptor_ = file->message_type(0);
  static const int Config_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, primary_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, keyvaluestore_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, tiering_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, cloud_),
  };
  Config_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Config_descriptor_,
      Config::default_instance_,
      Config_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Config));
  Primary_descriptor_ = file->message_type(1);
  static const int Primary_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Primary, host_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Primary, epoch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Primary, starttime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Primary, fuse_cache_enable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Primary, fuse_direct_io_),
  };
  Primary_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Primary_descriptor_,
      Primary::default_instance_,
      Primary_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Primary, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Primary, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Primary));
  KeyValueStore_descriptor_ = file->message_type(2);
  static const int KeyValueStore_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyValueStore, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyValueStore, filename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyValueStore, persistencerule_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyValueStore, maxsizebytes_),
  };
  KeyValueStore_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeyValueStore_descriptor_,
      KeyValueStore::default_instance_,
      KeyValueStore_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyValueStore, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyValueStore, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KeyValueStore));
  KeyValueStore_Type_descriptor_ = KeyValueStore_descriptor_->enum_type(0);
  KeyValueStore_PersistenceRule_descriptor_ = KeyValueStore_descriptor_->enum_type(1);
  Tiering_descriptor_ = file->message_type(3);
  static const int Tiering_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tiering, cachedir_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tiering, encryption_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tiering, encryptionkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tiering, compression_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tiering, mirrorlagseconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tiering, cachesizebytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tiering, cachefreepercent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tiering, maxobjectsizebytes_),
  };
  Tiering_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Tiering_descriptor_,
      Tiering::default_instance_,
      Tiering_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tiering, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tiering, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Tiering));
  Tiering_EncryptionAlgorithm_descriptor_ = Tiering_descriptor_->enum_type(0);
  Tiering_CompressionAlgorithm_descriptor_ = Tiering_descriptor_->enum_type(1);
  Cloud_descriptor_ = file->message_type(4);
  static const int Cloud_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cloud, protocol_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cloud, endpoint_),
  };
  Cloud_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Cloud_descriptor_,
      Cloud::default_instance_,
      Cloud_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cloud, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cloud, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Cloud));
  Cloud_CloudAccessProtocol_descriptor_ = Cloud_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_config_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Config_descriptor_, &Config::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Primary_descriptor_, &Primary::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeyValueStore_descriptor_, &KeyValueStore::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Tiering_descriptor_, &Tiering::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Cloud_descriptor_, &Cloud::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_config_2eproto() {
  delete Config::default_instance_;
  delete Config_reflection_;
  delete Primary::default_instance_;
  delete Primary_reflection_;
  delete Primary::_default_host_;
  delete KeyValueStore::default_instance_;
  delete KeyValueStore_reflection_;
  delete Tiering::default_instance_;
  delete Tiering_reflection_;
  delete Cloud::default_instance_;
  delete Cloud_reflection_;
}

void protobuf_AddDesc_config_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014config.proto\022\021pqfs.config.proto\"\340\001\n\006Co"
    "nfig\022\014\n\004name\030\001 \001(\t\022\014\n\004uuid\030\002 \001(\t\022+\n\007prim"
    "ary\030\003 \001(\0132\032.pqfs.config.proto.Primary\0227\n"
    "\rkeyValueStore\030\004 \001(\0132 .pqfs.config.proto"
    ".KeyValueStore\022+\n\007tiering\030\005 \001(\0132\032.pqfs.c"
    "onfig.proto.Tiering\022\'\n\005cloud\030\006 \001(\0132\030.pqf"
    "s.config.proto.Cloud\"\212\001\n\007Primary\022\027\n\004host"
    "\030\001 \001(\t:\tlocalhost\022\020\n\005epoch\030\002 \001(\003:\0011\022\024\n\ts"
    "tartTime\030\003 \001(\003:\0010\022\037\n\021fuse_cache_enable\030\004"
    " \001(\010:\004true\022\035\n\016fuse_direct_io\030\005 \001(\010:\005fals"
    "e\"\272\002\n\rKeyValueStore\022<\n\004type\030\001 \001(\0162%.pqfs"
    ".config.proto.KeyValueStore.Type:\007LEVELD"
    "B\022\022\n\010filename\030\002 \001(\t:\000\022O\n\017persistenceRule"
    "\030\003 \001(\01620.pqfs.config.proto.KeyValueStore"
    ".PersistenceRule:\004LAZY\022\037\n\014maxSizeBytes\030\004"
    " \001(\003:\t100000000\",\n\004Type\022\t\n\005ROXDB\020\000\022\013\n\007LE"
    "VELDB\020\001\022\014\n\010RAMCLOUD\020\002\"7\n\017PersistenceRule"
    "\022\014\n\010ON_WRITE\020\000\022\014\n\010ON_CLOSE\020\001\022\010\n\004LAZY\020\002\"\312"
    "\003\n\007Tiering\022\020\n\010cacheDir\030\001 \001(\t\022O\n\nencrypti"
    "on\030\002 \001(\0162..pqfs.config.proto.Tiering.Enc"
    "ryptionAlgorithm:\013UNENCRYPTED\022\027\n\rencrypt"
    "ionKey\030\003 \001(\t:\000\022I\n\013compression\030\004 \001(\0162/.pq"
    "fs.config.proto.Tiering.CompressionAlgor"
    "ithm:\003ZIP\022\033\n\020mirrorLagSeconds\030\005 \001(\003:\0010\022!"
    "\n\016cacheSizeBytes\030\006 \001(\003:\t100000000\022\034\n\020cac"
    "heFreePercent\030\007 \001(\005:\00220\022&\n\022maxObjectSize"
    "Bytes\030\010 \001(\003:\n1000000000\"3\n\023EncryptionAlg"
    "orithm\022\017\n\013UNENCRYPTED\020\000\022\013\n\007AES_128\020\001\"=\n\024"
    "CompressionAlgorithm\022\020\n\014UNCOMPRESSED\020\000\022\007"
    "\n\003ZIP\020\001\022\n\n\006SNAPPY\020\002\"\254\001\n\005Cloud\022I\n\010protoco"
    "l\030\001 \001(\0162,.pqfs.config.proto.Cloud.CloudA"
    "ccessProtocol:\tAMAZON_S3\022\020\n\010endpoint\030\002 \001"
    "(\t\"F\n\023CloudAccessProtocol\022\t\n\005LOCAL\020\000\022\r\n\t"
    "AMAZON_S3\020\001\022\025\n\021GOOGLE_STORAGE_V1\020\002", 1354);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "config.proto", &protobuf_RegisterTypes);
  Config::default_instance_ = new Config();
  Primary::_default_host_ =
      new ::std::string("localhost", 9);
  Primary::default_instance_ = new Primary();
  KeyValueStore::default_instance_ = new KeyValueStore();
  Tiering::default_instance_ = new Tiering();
  Cloud::default_instance_ = new Cloud();
  Config::default_instance_->InitAsDefaultInstance();
  Primary::default_instance_->InitAsDefaultInstance();
  KeyValueStore::default_instance_->InitAsDefaultInstance();
  Tiering::default_instance_->InitAsDefaultInstance();
  Cloud::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_config_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_config_2eproto {
  StaticDescriptorInitializer_config_2eproto() {
    protobuf_AddDesc_config_2eproto();
  }
} static_descriptor_initializer_config_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int Config::kNameFieldNumber;
const int Config::kUuidFieldNumber;
const int Config::kPrimaryFieldNumber;
const int Config::kKeyValueStoreFieldNumber;
const int Config::kTieringFieldNumber;
const int Config::kCloudFieldNumber;
#endif  // !_MSC_VER

Config::Config()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pqfs.config.proto.Config)
}

void Config::InitAsDefaultInstance() {
  primary_ = const_cast< ::pqfs::config::proto::Primary*>(&::pqfs::config::proto::Primary::default_instance());
  keyvaluestore_ = const_cast< ::pqfs::config::proto::KeyValueStore*>(&::pqfs::config::proto::KeyValueStore::default_instance());
  tiering_ = const_cast< ::pqfs::config::proto::Tiering*>(&::pqfs::config::proto::Tiering::default_instance());
  cloud_ = const_cast< ::pqfs::config::proto::Cloud*>(&::pqfs::config::proto::Cloud::default_instance());
}

Config::Config(const Config& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pqfs.config.proto.Config)
}

void Config::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  primary_ = NULL;
  keyvaluestore_ = NULL;
  tiering_ = NULL;
  cloud_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Config::~Config() {
  // @@protoc_insertion_point(destructor:pqfs.config.proto.Config)
  SharedDtor();
}

void Config::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uuid_;
  }
  if (this != default_instance_) {
    delete primary_;
    delete keyvaluestore_;
    delete tiering_;
    delete cloud_;
  }
}

void Config::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Config::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Config_descriptor_;
}

const Config& Config::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_config_2eproto();
  return *default_instance_;
}

Config* Config::default_instance_ = NULL;

Config* Config::New() const {
  return new Config;
}

void Config::Clear() {
  if (_has_bits_[0 / 32] & 63) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        uuid_->clear();
      }
    }
    if (has_primary()) {
      if (primary_ != NULL) primary_->::pqfs::config::proto::Primary::Clear();
    }
    if (has_keyvaluestore()) {
      if (keyvaluestore_ != NULL) keyvaluestore_->::pqfs::config::proto::KeyValueStore::Clear();
    }
    if (has_tiering()) {
      if (tiering_ != NULL) tiering_->::pqfs::config::proto::Tiering::Clear();
    }
    if (has_cloud()) {
      if (cloud_ != NULL) cloud_->::pqfs::config::proto::Cloud::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Config::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pqfs.config.proto.Config)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_uuid;
        break;
      }

      // optional string uuid = 2;
      case 2: {
        if (tag == 18) {
         parse_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uuid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->uuid().data(), this->uuid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "uuid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_primary;
        break;
      }

      // optional .pqfs.config.proto.Primary primary = 3;
      case 3: {
        if (tag == 26) {
         parse_primary:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_primary()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_keyValueStore;
        break;
      }

      // optional .pqfs.config.proto.KeyValueStore keyValueStore = 4;
      case 4: {
        if (tag == 34) {
         parse_keyValueStore:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_keyvaluestore()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_tiering;
        break;
      }

      // optional .pqfs.config.proto.Tiering tiering = 5;
      case 5: {
        if (tag == 42) {
         parse_tiering:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tiering()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_cloud;
        break;
      }

      // optional .pqfs.config.proto.Cloud cloud = 6;
      case 6: {
        if (tag == 50) {
         parse_cloud:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cloud()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pqfs.config.proto.Config)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pqfs.config.proto.Config)
  return false;
#undef DO_
}

void Config::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pqfs.config.proto.Config)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string uuid = 2;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "uuid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->uuid(), output);
  }

  // optional .pqfs.config.proto.Primary primary = 3;
  if (has_primary()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->primary(), output);
  }

  // optional .pqfs.config.proto.KeyValueStore keyValueStore = 4;
  if (has_keyvaluestore()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->keyvaluestore(), output);
  }

  // optional .pqfs.config.proto.Tiering tiering = 5;
  if (has_tiering()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->tiering(), output);
  }

  // optional .pqfs.config.proto.Cloud cloud = 6;
  if (has_cloud()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->cloud(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pqfs.config.proto.Config)
}

::google::protobuf::uint8* Config::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pqfs.config.proto.Config)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string uuid = 2;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "uuid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->uuid(), target);
  }

  // optional .pqfs.config.proto.Primary primary = 3;
  if (has_primary()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->primary(), target);
  }

  // optional .pqfs.config.proto.KeyValueStore keyValueStore = 4;
  if (has_keyvaluestore()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->keyvaluestore(), target);
  }

  // optional .pqfs.config.proto.Tiering tiering = 5;
  if (has_tiering()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->tiering(), target);
  }

  // optional .pqfs.config.proto.Cloud cloud = 6;
  if (has_cloud()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->cloud(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pqfs.config.proto.Config)
  return target;
}

int Config::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string uuid = 2;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uuid());
    }

    // optional .pqfs.config.proto.Primary primary = 3;
    if (has_primary()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->primary());
    }

    // optional .pqfs.config.proto.KeyValueStore keyValueStore = 4;
    if (has_keyvaluestore()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->keyvaluestore());
    }

    // optional .pqfs.config.proto.Tiering tiering = 5;
    if (has_tiering()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tiering());
    }

    // optional .pqfs.config.proto.Cloud cloud = 6;
    if (has_cloud()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cloud());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Config::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Config* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Config*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Config::MergeFrom(const Config& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_primary()) {
      mutable_primary()->::pqfs::config::proto::Primary::MergeFrom(from.primary());
    }
    if (from.has_keyvaluestore()) {
      mutable_keyvaluestore()->::pqfs::config::proto::KeyValueStore::MergeFrom(from.keyvaluestore());
    }
    if (from.has_tiering()) {
      mutable_tiering()->::pqfs::config::proto::Tiering::MergeFrom(from.tiering());
    }
    if (from.has_cloud()) {
      mutable_cloud()->::pqfs::config::proto::Cloud::MergeFrom(from.cloud());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Config::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Config::CopyFrom(const Config& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Config::IsInitialized() const {

  return true;
}

void Config::Swap(Config* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(uuid_, other->uuid_);
    std::swap(primary_, other->primary_);
    std::swap(keyvaluestore_, other->keyvaluestore_);
    std::swap(tiering_, other->tiering_);
    std::swap(cloud_, other->cloud_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Config::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Config_descriptor_;
  metadata.reflection = Config_reflection_;
  return metadata;
}


// ===================================================================

::std::string* Primary::_default_host_ = NULL;
#ifndef _MSC_VER
const int Primary::kHostFieldNumber;
const int Primary::kEpochFieldNumber;
const int Primary::kStartTimeFieldNumber;
const int Primary::kFuseCacheEnableFieldNumber;
const int Primary::kFuseDirectIoFieldNumber;
#endif  // !_MSC_VER

Primary::Primary()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pqfs.config.proto.Primary)
}

void Primary::InitAsDefaultInstance() {
}

Primary::Primary(const Primary& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pqfs.config.proto.Primary)
}

void Primary::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  host_ = const_cast< ::std::string*>(_default_host_);
  epoch_ = GOOGLE_LONGLONG(1);
  starttime_ = GOOGLE_LONGLONG(0);
  fuse_cache_enable_ = true;
  fuse_direct_io_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Primary::~Primary() {
  // @@protoc_insertion_point(destructor:pqfs.config.proto.Primary)
  SharedDtor();
}

void Primary::SharedDtor() {
  if (host_ != _default_host_) {
    delete host_;
  }
  if (this != default_instance_) {
  }
}

void Primary::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Primary::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Primary_descriptor_;
}

const Primary& Primary::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_config_2eproto();
  return *default_instance_;
}

Primary* Primary::default_instance_ = NULL;

Primary* Primary::New() const {
  return new Primary;
}

void Primary::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    if (has_host()) {
      if (host_ != _default_host_) {
        host_->assign(*_default_host_);
      }
    }
    epoch_ = GOOGLE_LONGLONG(1);
    starttime_ = GOOGLE_LONGLONG(0);
    fuse_cache_enable_ = true;
    fuse_direct_io_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Primary::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pqfs.config.proto.Primary)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string host = 1 [default = "localhost"];
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_host()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->host().data(), this->host().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "host");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_epoch;
        break;
      }

      // optional int64 epoch = 2 [default = 1];
      case 2: {
        if (tag == 16) {
         parse_epoch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &epoch_)));
          set_has_epoch();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_startTime;
        break;
      }

      // optional int64 startTime = 3 [default = 0];
      case 3: {
        if (tag == 24) {
         parse_startTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &starttime_)));
          set_has_starttime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_fuse_cache_enable;
        break;
      }

      // optional bool fuse_cache_enable = 4 [default = true];
      case 4: {
        if (tag == 32) {
         parse_fuse_cache_enable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &fuse_cache_enable_)));
          set_has_fuse_cache_enable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_fuse_direct_io;
        break;
      }

      // optional bool fuse_direct_io = 5 [default = false];
      case 5: {
        if (tag == 40) {
         parse_fuse_direct_io:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &fuse_direct_io_)));
          set_has_fuse_direct_io();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pqfs.config.proto.Primary)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pqfs.config.proto.Primary)
  return false;
#undef DO_
}

void Primary::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pqfs.config.proto.Primary)
  // optional string host = 1 [default = "localhost"];
  if (has_host()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->host().data(), this->host().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "host");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->host(), output);
  }

  // optional int64 epoch = 2 [default = 1];
  if (has_epoch()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->epoch(), output);
  }

  // optional int64 startTime = 3 [default = 0];
  if (has_starttime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->starttime(), output);
  }

  // optional bool fuse_cache_enable = 4 [default = true];
  if (has_fuse_cache_enable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->fuse_cache_enable(), output);
  }

  // optional bool fuse_direct_io = 5 [default = false];
  if (has_fuse_direct_io()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->fuse_direct_io(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pqfs.config.proto.Primary)
}

::google::protobuf::uint8* Primary::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pqfs.config.proto.Primary)
  // optional string host = 1 [default = "localhost"];
  if (has_host()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->host().data(), this->host().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "host");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->host(), target);
  }

  // optional int64 epoch = 2 [default = 1];
  if (has_epoch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->epoch(), target);
  }

  // optional int64 startTime = 3 [default = 0];
  if (has_starttime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->starttime(), target);
  }

  // optional bool fuse_cache_enable = 4 [default = true];
  if (has_fuse_cache_enable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->fuse_cache_enable(), target);
  }

  // optional bool fuse_direct_io = 5 [default = false];
  if (has_fuse_direct_io()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->fuse_direct_io(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pqfs.config.proto.Primary)
  return target;
}

int Primary::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string host = 1 [default = "localhost"];
    if (has_host()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->host());
    }

    // optional int64 epoch = 2 [default = 1];
    if (has_epoch()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->epoch());
    }

    // optional int64 startTime = 3 [default = 0];
    if (has_starttime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->starttime());
    }

    // optional bool fuse_cache_enable = 4 [default = true];
    if (has_fuse_cache_enable()) {
      total_size += 1 + 1;
    }

    // optional bool fuse_direct_io = 5 [default = false];
    if (has_fuse_direct_io()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Primary::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Primary* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Primary*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Primary::MergeFrom(const Primary& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_host()) {
      set_host(from.host());
    }
    if (from.has_epoch()) {
      set_epoch(from.epoch());
    }
    if (from.has_starttime()) {
      set_starttime(from.starttime());
    }
    if (from.has_fuse_cache_enable()) {
      set_fuse_cache_enable(from.fuse_cache_enable());
    }
    if (from.has_fuse_direct_io()) {
      set_fuse_direct_io(from.fuse_direct_io());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Primary::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Primary::CopyFrom(const Primary& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Primary::IsInitialized() const {

  return true;
}

void Primary::Swap(Primary* other) {
  if (other != this) {
    std::swap(host_, other->host_);
    std::swap(epoch_, other->epoch_);
    std::swap(starttime_, other->starttime_);
    std::swap(fuse_cache_enable_, other->fuse_cache_enable_);
    std::swap(fuse_direct_io_, other->fuse_direct_io_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Primary::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Primary_descriptor_;
  metadata.reflection = Primary_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* KeyValueStore_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyValueStore_Type_descriptor_;
}
bool KeyValueStore_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const KeyValueStore_Type KeyValueStore::ROXDB;
const KeyValueStore_Type KeyValueStore::LEVELDB;
const KeyValueStore_Type KeyValueStore::RAMCLOUD;
const KeyValueStore_Type KeyValueStore::Type_MIN;
const KeyValueStore_Type KeyValueStore::Type_MAX;
const int KeyValueStore::Type_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* KeyValueStore_PersistenceRule_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyValueStore_PersistenceRule_descriptor_;
}
bool KeyValueStore_PersistenceRule_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const KeyValueStore_PersistenceRule KeyValueStore::ON_WRITE;
const KeyValueStore_PersistenceRule KeyValueStore::ON_CLOSE;
const KeyValueStore_PersistenceRule KeyValueStore::LAZY;
const KeyValueStore_PersistenceRule KeyValueStore::PersistenceRule_MIN;
const KeyValueStore_PersistenceRule KeyValueStore::PersistenceRule_MAX;
const int KeyValueStore::PersistenceRule_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int KeyValueStore::kTypeFieldNumber;
const int KeyValueStore::kFilenameFieldNumber;
const int KeyValueStore::kPersistenceRuleFieldNumber;
const int KeyValueStore::kMaxSizeBytesFieldNumber;
#endif  // !_MSC_VER

KeyValueStore::KeyValueStore()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pqfs.config.proto.KeyValueStore)
}

void KeyValueStore::InitAsDefaultInstance() {
}

KeyValueStore::KeyValueStore(const KeyValueStore& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pqfs.config.proto.KeyValueStore)
}

void KeyValueStore::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 1;
  filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  persistencerule_ = 2;
  maxsizebytes_ = GOOGLE_LONGLONG(100000000);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeyValueStore::~KeyValueStore() {
  // @@protoc_insertion_point(destructor:pqfs.config.proto.KeyValueStore)
  SharedDtor();
}

void KeyValueStore::SharedDtor() {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filename_;
  }
  if (this != default_instance_) {
  }
}

void KeyValueStore::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KeyValueStore::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyValueStore_descriptor_;
}

const KeyValueStore& KeyValueStore::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_config_2eproto();
  return *default_instance_;
}

KeyValueStore* KeyValueStore::default_instance_ = NULL;

KeyValueStore* KeyValueStore::New() const {
  return new KeyValueStore;
}

void KeyValueStore::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    type_ = 1;
    if (has_filename()) {
      if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        filename_->clear();
      }
    }
    persistencerule_ = 2;
    maxsizebytes_ = GOOGLE_LONGLONG(100000000);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeyValueStore::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pqfs.config.proto.KeyValueStore)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .pqfs.config.proto.KeyValueStore.Type type = 1 [default = LEVELDB];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pqfs::config::proto::KeyValueStore_Type_IsValid(value)) {
            set_type(static_cast< ::pqfs::config::proto::KeyValueStore_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_filename;
        break;
      }

      // optional string filename = 2 [default = ""];
      case 2: {
        if (tag == 18) {
         parse_filename:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->filename().data(), this->filename().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "filename");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_persistenceRule;
        break;
      }

      // optional .pqfs.config.proto.KeyValueStore.PersistenceRule persistenceRule = 3 [default = LAZY];
      case 3: {
        if (tag == 24) {
         parse_persistenceRule:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pqfs::config::proto::KeyValueStore_PersistenceRule_IsValid(value)) {
            set_persistencerule(static_cast< ::pqfs::config::proto::KeyValueStore_PersistenceRule >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_maxSizeBytes;
        break;
      }

      // optional int64 maxSizeBytes = 4 [default = 100000000];
      case 4: {
        if (tag == 32) {
         parse_maxSizeBytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &maxsizebytes_)));
          set_has_maxsizebytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pqfs.config.proto.KeyValueStore)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pqfs.config.proto.KeyValueStore)
  return false;
#undef DO_
}

void KeyValueStore::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pqfs.config.proto.KeyValueStore)
  // optional .pqfs.config.proto.KeyValueStore.Type type = 1 [default = LEVELDB];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional string filename = 2 [default = ""];
  if (has_filename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->filename().data(), this->filename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "filename");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->filename(), output);
  }

  // optional .pqfs.config.proto.KeyValueStore.PersistenceRule persistenceRule = 3 [default = LAZY];
  if (has_persistencerule()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->persistencerule(), output);
  }

  // optional int64 maxSizeBytes = 4 [default = 100000000];
  if (has_maxsizebytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->maxsizebytes(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pqfs.config.proto.KeyValueStore)
}

::google::protobuf::uint8* KeyValueStore::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pqfs.config.proto.KeyValueStore)
  // optional .pqfs.config.proto.KeyValueStore.Type type = 1 [default = LEVELDB];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional string filename = 2 [default = ""];
  if (has_filename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->filename().data(), this->filename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "filename");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->filename(), target);
  }

  // optional .pqfs.config.proto.KeyValueStore.PersistenceRule persistenceRule = 3 [default = LAZY];
  if (has_persistencerule()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->persistencerule(), target);
  }

  // optional int64 maxSizeBytes = 4 [default = 100000000];
  if (has_maxsizebytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->maxsizebytes(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pqfs.config.proto.KeyValueStore)
  return target;
}

int KeyValueStore::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .pqfs.config.proto.KeyValueStore.Type type = 1 [default = LEVELDB];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional string filename = 2 [default = ""];
    if (has_filename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filename());
    }

    // optional .pqfs.config.proto.KeyValueStore.PersistenceRule persistenceRule = 3 [default = LAZY];
    if (has_persistencerule()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->persistencerule());
    }

    // optional int64 maxSizeBytes = 4 [default = 100000000];
    if (has_maxsizebytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->maxsizebytes());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyValueStore::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeyValueStore* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeyValueStore*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeyValueStore::MergeFrom(const KeyValueStore& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_filename()) {
      set_filename(from.filename());
    }
    if (from.has_persistencerule()) {
      set_persistencerule(from.persistencerule());
    }
    if (from.has_maxsizebytes()) {
      set_maxsizebytes(from.maxsizebytes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeyValueStore::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyValueStore::CopyFrom(const KeyValueStore& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyValueStore::IsInitialized() const {

  return true;
}

void KeyValueStore::Swap(KeyValueStore* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(filename_, other->filename_);
    std::swap(persistencerule_, other->persistencerule_);
    std::swap(maxsizebytes_, other->maxsizebytes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KeyValueStore::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KeyValueStore_descriptor_;
  metadata.reflection = KeyValueStore_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Tiering_EncryptionAlgorithm_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Tiering_EncryptionAlgorithm_descriptor_;
}
bool Tiering_EncryptionAlgorithm_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Tiering_EncryptionAlgorithm Tiering::UNENCRYPTED;
const Tiering_EncryptionAlgorithm Tiering::AES_128;
const Tiering_EncryptionAlgorithm Tiering::EncryptionAlgorithm_MIN;
const Tiering_EncryptionAlgorithm Tiering::EncryptionAlgorithm_MAX;
const int Tiering::EncryptionAlgorithm_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Tiering_CompressionAlgorithm_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Tiering_CompressionAlgorithm_descriptor_;
}
bool Tiering_CompressionAlgorithm_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Tiering_CompressionAlgorithm Tiering::UNCOMPRESSED;
const Tiering_CompressionAlgorithm Tiering::ZIP;
const Tiering_CompressionAlgorithm Tiering::SNAPPY;
const Tiering_CompressionAlgorithm Tiering::CompressionAlgorithm_MIN;
const Tiering_CompressionAlgorithm Tiering::CompressionAlgorithm_MAX;
const int Tiering::CompressionAlgorithm_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Tiering::kCacheDirFieldNumber;
const int Tiering::kEncryptionFieldNumber;
const int Tiering::kEncryptionKeyFieldNumber;
const int Tiering::kCompressionFieldNumber;
const int Tiering::kMirrorLagSecondsFieldNumber;
const int Tiering::kCacheSizeBytesFieldNumber;
const int Tiering::kCacheFreePercentFieldNumber;
const int Tiering::kMaxObjectSizeBytesFieldNumber;
#endif  // !_MSC_VER

Tiering::Tiering()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pqfs.config.proto.Tiering)
}

void Tiering::InitAsDefaultInstance() {
}

Tiering::Tiering(const Tiering& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pqfs.config.proto.Tiering)
}

void Tiering::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  cachedir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  encryption_ = 0;
  encryptionkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  compression_ = 1;
  mirrorlagseconds_ = GOOGLE_LONGLONG(0);
  cachesizebytes_ = GOOGLE_LONGLONG(100000000);
  cachefreepercent_ = 20;
  maxobjectsizebytes_ = GOOGLE_LONGLONG(1000000000);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Tiering::~Tiering() {
  // @@protoc_insertion_point(destructor:pqfs.config.proto.Tiering)
  SharedDtor();
}

void Tiering::SharedDtor() {
  if (cachedir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cachedir_;
  }
  if (encryptionkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encryptionkey_;
  }
  if (this != default_instance_) {
  }
}

void Tiering::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Tiering::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Tiering_descriptor_;
}

const Tiering& Tiering::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_config_2eproto();
  return *default_instance_;
}

Tiering* Tiering::default_instance_ = NULL;

Tiering* Tiering::New() const {
  return new Tiering;
}

void Tiering::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    if (has_cachedir()) {
      if (cachedir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        cachedir_->clear();
      }
    }
    encryption_ = 0;
    if (has_encryptionkey()) {
      if (encryptionkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        encryptionkey_->clear();
      }
    }
    compression_ = 1;
    mirrorlagseconds_ = GOOGLE_LONGLONG(0);
    cachesizebytes_ = GOOGLE_LONGLONG(100000000);
    cachefreepercent_ = 20;
    maxobjectsizebytes_ = GOOGLE_LONGLONG(1000000000);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Tiering::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pqfs.config.proto.Tiering)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string cacheDir = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cachedir()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->cachedir().data(), this->cachedir().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "cachedir");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_encryption;
        break;
      }

      // optional .pqfs.config.proto.Tiering.EncryptionAlgorithm encryption = 2 [default = UNENCRYPTED];
      case 2: {
        if (tag == 16) {
         parse_encryption:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pqfs::config::proto::Tiering_EncryptionAlgorithm_IsValid(value)) {
            set_encryption(static_cast< ::pqfs::config::proto::Tiering_EncryptionAlgorithm >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_encryptionKey;
        break;
      }

      // optional string encryptionKey = 3 [default = ""];
      case 3: {
        if (tag == 26) {
         parse_encryptionKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_encryptionkey()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->encryptionkey().data(), this->encryptionkey().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "encryptionkey");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_compression;
        break;
      }

      // optional .pqfs.config.proto.Tiering.CompressionAlgorithm compression = 4 [default = ZIP];
      case 4: {
        if (tag == 32) {
         parse_compression:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pqfs::config::proto::Tiering_CompressionAlgorithm_IsValid(value)) {
            set_compression(static_cast< ::pqfs::config::proto::Tiering_CompressionAlgorithm >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_mirrorLagSeconds;
        break;
      }

      // optional int64 mirrorLagSeconds = 5 [default = 0];
      case 5: {
        if (tag == 40) {
         parse_mirrorLagSeconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &mirrorlagseconds_)));
          set_has_mirrorlagseconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_cacheSizeBytes;
        break;
      }

      // optional int64 cacheSizeBytes = 6 [default = 100000000];
      case 6: {
        if (tag == 48) {
         parse_cacheSizeBytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &cachesizebytes_)));
          set_has_cachesizebytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_cacheFreePercent;
        break;
      }

      // optional int32 cacheFreePercent = 7 [default = 20];
      case 7: {
        if (tag == 56) {
         parse_cacheFreePercent:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cachefreepercent_)));
          set_has_cachefreepercent();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_maxObjectSizeBytes;
        break;
      }

      // optional int64 maxObjectSizeBytes = 8 [default = 1000000000];
      case 8: {
        if (tag == 64) {
         parse_maxObjectSizeBytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &maxobjectsizebytes_)));
          set_has_maxobjectsizebytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pqfs.config.proto.Tiering)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pqfs.config.proto.Tiering)
  return false;
#undef DO_
}

void Tiering::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pqfs.config.proto.Tiering)
  // optional string cacheDir = 1;
  if (has_cachedir()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->cachedir().data(), this->cachedir().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "cachedir");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->cachedir(), output);
  }

  // optional .pqfs.config.proto.Tiering.EncryptionAlgorithm encryption = 2 [default = UNENCRYPTED];
  if (has_encryption()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->encryption(), output);
  }

  // optional string encryptionKey = 3 [default = ""];
  if (has_encryptionkey()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->encryptionkey().data(), this->encryptionkey().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "encryptionkey");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->encryptionkey(), output);
  }

  // optional .pqfs.config.proto.Tiering.CompressionAlgorithm compression = 4 [default = ZIP];
  if (has_compression()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->compression(), output);
  }

  // optional int64 mirrorLagSeconds = 5 [default = 0];
  if (has_mirrorlagseconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->mirrorlagseconds(), output);
  }

  // optional int64 cacheSizeBytes = 6 [default = 100000000];
  if (has_cachesizebytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->cachesizebytes(), output);
  }

  // optional int32 cacheFreePercent = 7 [default = 20];
  if (has_cachefreepercent()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->cachefreepercent(), output);
  }

  // optional int64 maxObjectSizeBytes = 8 [default = 1000000000];
  if (has_maxobjectsizebytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(8, this->maxobjectsizebytes(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pqfs.config.proto.Tiering)
}

::google::protobuf::uint8* Tiering::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pqfs.config.proto.Tiering)
  // optional string cacheDir = 1;
  if (has_cachedir()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->cachedir().data(), this->cachedir().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "cachedir");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->cachedir(), target);
  }

  // optional .pqfs.config.proto.Tiering.EncryptionAlgorithm encryption = 2 [default = UNENCRYPTED];
  if (has_encryption()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->encryption(), target);
  }

  // optional string encryptionKey = 3 [default = ""];
  if (has_encryptionkey()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->encryptionkey().data(), this->encryptionkey().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "encryptionkey");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->encryptionkey(), target);
  }

  // optional .pqfs.config.proto.Tiering.CompressionAlgorithm compression = 4 [default = ZIP];
  if (has_compression()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->compression(), target);
  }

  // optional int64 mirrorLagSeconds = 5 [default = 0];
  if (has_mirrorlagseconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->mirrorlagseconds(), target);
  }

  // optional int64 cacheSizeBytes = 6 [default = 100000000];
  if (has_cachesizebytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(6, this->cachesizebytes(), target);
  }

  // optional int32 cacheFreePercent = 7 [default = 20];
  if (has_cachefreepercent()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->cachefreepercent(), target);
  }

  // optional int64 maxObjectSizeBytes = 8 [default = 1000000000];
  if (has_maxobjectsizebytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(8, this->maxobjectsizebytes(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pqfs.config.proto.Tiering)
  return target;
}

int Tiering::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string cacheDir = 1;
    if (has_cachedir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->cachedir());
    }

    // optional .pqfs.config.proto.Tiering.EncryptionAlgorithm encryption = 2 [default = UNENCRYPTED];
    if (has_encryption()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->encryption());
    }

    // optional string encryptionKey = 3 [default = ""];
    if (has_encryptionkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->encryptionkey());
    }

    // optional .pqfs.config.proto.Tiering.CompressionAlgorithm compression = 4 [default = ZIP];
    if (has_compression()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->compression());
    }

    // optional int64 mirrorLagSeconds = 5 [default = 0];
    if (has_mirrorlagseconds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->mirrorlagseconds());
    }

    // optional int64 cacheSizeBytes = 6 [default = 100000000];
    if (has_cachesizebytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->cachesizebytes());
    }

    // optional int32 cacheFreePercent = 7 [default = 20];
    if (has_cachefreepercent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cachefreepercent());
    }

    // optional int64 maxObjectSizeBytes = 8 [default = 1000000000];
    if (has_maxobjectsizebytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->maxobjectsizebytes());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Tiering::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Tiering* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Tiering*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Tiering::MergeFrom(const Tiering& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cachedir()) {
      set_cachedir(from.cachedir());
    }
    if (from.has_encryption()) {
      set_encryption(from.encryption());
    }
    if (from.has_encryptionkey()) {
      set_encryptionkey(from.encryptionkey());
    }
    if (from.has_compression()) {
      set_compression(from.compression());
    }
    if (from.has_mirrorlagseconds()) {
      set_mirrorlagseconds(from.mirrorlagseconds());
    }
    if (from.has_cachesizebytes()) {
      set_cachesizebytes(from.cachesizebytes());
    }
    if (from.has_cachefreepercent()) {
      set_cachefreepercent(from.cachefreepercent());
    }
    if (from.has_maxobjectsizebytes()) {
      set_maxobjectsizebytes(from.maxobjectsizebytes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Tiering::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Tiering::CopyFrom(const Tiering& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tiering::IsInitialized() const {

  return true;
}

void Tiering::Swap(Tiering* other) {
  if (other != this) {
    std::swap(cachedir_, other->cachedir_);
    std::swap(encryption_, other->encryption_);
    std::swap(encryptionkey_, other->encryptionkey_);
    std::swap(compression_, other->compression_);
    std::swap(mirrorlagseconds_, other->mirrorlagseconds_);
    std::swap(cachesizebytes_, other->cachesizebytes_);
    std::swap(cachefreepercent_, other->cachefreepercent_);
    std::swap(maxobjectsizebytes_, other->maxobjectsizebytes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Tiering::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Tiering_descriptor_;
  metadata.reflection = Tiering_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Cloud_CloudAccessProtocol_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Cloud_CloudAccessProtocol_descriptor_;
}
bool Cloud_CloudAccessProtocol_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Cloud_CloudAccessProtocol Cloud::LOCAL;
const Cloud_CloudAccessProtocol Cloud::AMAZON_S3;
const Cloud_CloudAccessProtocol Cloud::GOOGLE_STORAGE_V1;
const Cloud_CloudAccessProtocol Cloud::CloudAccessProtocol_MIN;
const Cloud_CloudAccessProtocol Cloud::CloudAccessProtocol_MAX;
const int Cloud::CloudAccessProtocol_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Cloud::kProtocolFieldNumber;
const int Cloud::kEndpointFieldNumber;
#endif  // !_MSC_VER

Cloud::Cloud()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pqfs.config.proto.Cloud)
}

void Cloud::InitAsDefaultInstance() {
}

Cloud::Cloud(const Cloud& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pqfs.config.proto.Cloud)
}

void Cloud::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  protocol_ = 1;
  endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Cloud::~Cloud() {
  // @@protoc_insertion_point(destructor:pqfs.config.proto.Cloud)
  SharedDtor();
}

void Cloud::SharedDtor() {
  if (endpoint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete endpoint_;
  }
  if (this != default_instance_) {
  }
}

void Cloud::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Cloud::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Cloud_descriptor_;
}

const Cloud& Cloud::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_config_2eproto();
  return *default_instance_;
}

Cloud* Cloud::default_instance_ = NULL;

Cloud* Cloud::New() const {
  return new Cloud;
}

void Cloud::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    protocol_ = 1;
    if (has_endpoint()) {
      if (endpoint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        endpoint_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Cloud::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pqfs.config.proto.Cloud)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .pqfs.config.proto.Cloud.CloudAccessProtocol protocol = 1 [default = AMAZON_S3];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pqfs::config::proto::Cloud_CloudAccessProtocol_IsValid(value)) {
            set_protocol(static_cast< ::pqfs::config::proto::Cloud_CloudAccessProtocol >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_endpoint;
        break;
      }

      // optional string endpoint = 2;
      case 2: {
        if (tag == 18) {
         parse_endpoint:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_endpoint()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->endpoint().data(), this->endpoint().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "endpoint");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pqfs.config.proto.Cloud)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pqfs.config.proto.Cloud)
  return false;
#undef DO_
}

void Cloud::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pqfs.config.proto.Cloud)
  // optional .pqfs.config.proto.Cloud.CloudAccessProtocol protocol = 1 [default = AMAZON_S3];
  if (has_protocol()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->protocol(), output);
  }

  // optional string endpoint = 2;
  if (has_endpoint()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->endpoint().data(), this->endpoint().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "endpoint");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->endpoint(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pqfs.config.proto.Cloud)
}

::google::protobuf::uint8* Cloud::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pqfs.config.proto.Cloud)
  // optional .pqfs.config.proto.Cloud.CloudAccessProtocol protocol = 1 [default = AMAZON_S3];
  if (has_protocol()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->protocol(), target);
  }

  // optional string endpoint = 2;
  if (has_endpoint()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->endpoint().data(), this->endpoint().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "endpoint");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->endpoint(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pqfs.config.proto.Cloud)
  return target;
}

int Cloud::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .pqfs.config.proto.Cloud.CloudAccessProtocol protocol = 1 [default = AMAZON_S3];
    if (has_protocol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->protocol());
    }

    // optional string endpoint = 2;
    if (has_endpoint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->endpoint());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Cloud::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Cloud* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Cloud*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Cloud::MergeFrom(const Cloud& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_protocol()) {
      set_protocol(from.protocol());
    }
    if (from.has_endpoint()) {
      set_endpoint(from.endpoint());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Cloud::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Cloud::CopyFrom(const Cloud& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cloud::IsInitialized() const {

  return true;
}

void Cloud::Swap(Cloud* other) {
  if (other != this) {
    std::swap(protocol_, other->protocol_);
    std::swap(endpoint_, other->endpoint_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Cloud::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Cloud_descriptor_;
  metadata.reflection = Cloud_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace config
}  // namespace pqfs

// @@protoc_insertion_point(global_scope)
